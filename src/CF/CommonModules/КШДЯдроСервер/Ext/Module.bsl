#Область ПрограммныйИнтерфейс

#Область СервисОчередиДанных

// Добавление нового сообщения в очередь сервиса, для которого он предназначен
//
// Параметры:
//  ИдентификаторСервиса	 - Строка	 - Идентификатор сервиса, которому должно быть доставлено сообщение
//  Контур					 - Строка	 - Контур в рамках которого отправляется сообщение
//  Пакет					 - Строка	 - Данные для передачи сообщением
//  ИдентификаторСообщения	 - Строка	 - Уникальный идентификатор сообщения (сохраняется до конца маршрута)
// 
// Возвращаемое значение:
//	Структура:
//		* Успешно - Булево - признак успешности завершения действий
//		* Ошибка - Строка - содержит информацию об ошибке, возникшей при выполнении
//
Функция ДобавитьПакетВОчередь(ИдентификаторСервиса, Контур, Пакет, ИдентификаторСообщения = Неопределено) Экспорт
	Результат = Новый Структура;
	Результат.Вставить("Успешно", Ложь);
	Результат.Вставить("Ошибка", "");
	
	Если Не ЗначениеЗаполнено(ИдентификаторСервиса) Тогда
		Результат.Ошибка = "Не указан идентификатор сервиса, для которого отправляется сообщение";
		
		Возврат Результат;
	КонецЕсли;
	//Добавить проверку наличия сервиса
	
	Если Не ЗначениеЗаполнено(Контур) Тогда
		Результат.Ошибка = "Не указан идентификатор сервиса, для которого отправляется сообщение";
		
		Возврат Результат;
	Иначе
		СписокКонтуров = КШДЯдроВызовСервераПовтИсп.ЗначениеИзКэша("", Перечисления.КШДЯдроКлючиКэшаНастроек.МассивКонтуров);
		Найден = Ложь;
		Для Каждого ТекКонтур Из СписокКонтуров Цикл
			Если ТекКонтур.id = Контур Тогда
				Найден = Истина;
			КонецЕсли;
		КонецЦикла;
		Если Не Найден Тогда
			Результат.Ошибка = "Не указан контур, для которого отправляется сообщение";
			
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(Пакет) Тогда
		Результат.Ошибка = "Пакет для передачи не содержит данных";
		
		Возврат Результат;
	КонецЕсли;
	//Добавить проверку корректности пакета
	
	Если Не ЗначениеЗаполнено(ИдентификаторСообщения) Тогда
		ИдентификаторСообщения = Строка(Новый УникальныйИдентификатор);
	КонецЕсли;
	
	МассивПараметров = Новый Массив;
	МассивПараметров.Добавить(ИдентификаторСервиса);
	МассивПараметров.Добавить(Контур);
	МассивПараметров.Добавить(Пакет);
	МассивПараметров.Добавить(ИдентификаторСообщения);
	
	ФоновыеЗадания.Выполнить("КШДЯдроСервер.ДобавитьСообщениеВОчередьВФоне", МассивПараметров);
	
	Результат.Успешно = Истина;
	
	Возврат Результат;
КонецФункции

// Фоновая процедура записи сообщения в очередь
//
// Параметры:
//  ИдентификаторСервиса	 - Строка	 - Идентификатор сервиса, которому должно быть доставлено сообщение
//  Контур					 - Строка	 - Контур в рамках которого отправляется сообщение
//  Пакет					 - Строка	 - Данные для передачи сообщением
//  ИдентификаторСообщения	 - Строка	 - Уникальный идентификатор сообщения
//
Процедура ДобавитьСообщениеВОчередьВФоне(ИдентификаторСервиса, Контур, Пакет, ИдентификаторСообщения) Экспорт
	
	Рег = РегистрыСведений.КШДЯдроОчередьСообщенийУзла.СоздатьМенеджерЗаписи();
	
	Рег.ИдентификаторСервиса = ИдентификаторСервиса;
	Рег.ИдентификаторСообщения = ИдентификаторСообщения;
	
	Рег.ДатаЗаписи = ТекущаяУниверсальнаяДатаВМиллисекундах();
	Рег.Контур = Контур;
	Рег.Пакет = Пакет;
	
	Рег.Записать(Истина);
	
	ЗафиксироватьСобытиеОчереди(ИдентификаторСервиса, ИдентификаторСообщения, 
		Перечисления.КШДЯдроВидыСобытий.Добавление);
	
КонецПроцедуры

// Получает не прочитанное ранее сообщение из очереди для конкретного сервиса
//
// Параметры:
//  ИдентификаторСервиса - Строка - Идентификатор сервиса для которого получаем сообщение
// 
// Возвращаемое значение:
//	Структура:
//		* ЕстьСообщение - Булево - признак наличия нового сообщения
//		* Ошибка - Строка - содержит информацию об ошибке, возникшей при выполнении
//		* Контур - Строка - контур сообщения
//		* Пакет - Строка - пакет сообщения
//		* ИдентификаторСообщения - Строка - идентификатор сообщения
//
Функция НачатьЧтениеСообщенияИзОчереди(ИдентификаторСервиса) Экспорт
	Результат = Новый Структура;
	Результат.Вставить("ЕстьСообщение", Ложь);
	Результат.Вставить("Ошибка", "");
	Результат.Вставить("Контур", "");
	Результат.Вставить("Пакет", "");
	Результат.Вставить("ИдентификаторСообщения", "");
	
	МассивКонтуров = КШДЯдроВызовСервераПовтИсп.ЗначениеИзКэша("", Перечисления.КШДЯдроКлючиКэшаНастроек.УзелКонтуры);
	
	НачатьТранзакцию();
	Попытка

		Блокировка = Новый БлокировкаДанных;
		БлокировкаРегистра = Блокировка.Добавить("РегистрСведений.КШДЯдроОчередьСообщенийУзла");
		БлокировкаРегистра.УстановитьЗначение("ИдентификаторСервиса", ИдентификаторСервиса);
		БлокировкаРегистра.Режим = РежимБлокировкиДанных.Исключительный;
		Блокировка.Заблокировать();
		
		Запрос = Новый Запрос;
		Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
		               |	КШДЯдроОчередьСообщенийУзла.ИдентификаторСервиса КАК ИдентификаторСервиса,
		               |	КШДЯдроОчередьСообщенийУзла.ИдентификаторСообщения КАК ИдентификаторСообщения
		               |ИЗ
		               |	РегистрСведений.КШДЯдроОчередьСообщенийУзла КАК КШДЯдроОчередьСообщенийУзла
		               |ГДЕ
		               |	КШДЯдроОчередьСообщенийУзла.ВОбработке = 0
		               |
		               |УПОРЯДОЧИТЬ ПО
		               |	ДатаЗаписи";
		РезультатЗапроса = Запрос.Выполнить();
		Если Не РезультатЗапроса.Пустой() Тогда
			Результат.ЕстьСообщение = Истина;
			
			Выборка = РезультатЗапроса.Выбрать();
			Выборка.Следующий();
			
			Рег = РегистрыСведений.КШДЯдроОчередьСообщенийУзла.СоздатьМенеджерЗаписи();
			Рег.ИдентификаторСервиса = Выборка.ИдентификаторСервиса;
			Рег.ИдентификаторСообщения = Выборка.ИдентификаторСообщения;
			
			Рег.Прочитать();
			
			Если Не Рег.Выбран() Тогда
				ВызватьИсключение "Не прочитана запись регистра очереди сообщений";
			КонецЕсли;
			
			Результат.Контур = Рег.Контур;
			Результат.Пакет = Рег.Пакет;
			Результат.ИдентификаторСообщения = Рег.ИдентификаторСообщения;
			
			Рег.ВОбработке = ТекущаяУниверсальнаяДатаВМиллисекундах();
			Рег.Записать(Истина);
		КонецЕсли;
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		Результат.Ошибка = ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		
		ОписаниеОшибки = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		
		// BSLLS:UsageWriteLogEvent-off
		ЗаписьЖурналаРегистрации("КШД.Ядро.Чтение сообщения из очереди", УровеньЖурналаРегистрации.Ошибка, , ,
			"При чтении сообщения из очереди возникла ошибка:" + Символы.ПС + ОписаниеОшибки);
		// BSLLS:UsageWriteLogEvent-on
		
	КонецПопытки;
	
	ЗафиксироватьСобытиеОчереди(ИдентификаторСервиса, Результат.ИдентификаторСообщения, 
		Перечисления.КШДЯдроВидыСобытий.Чтение, Результат.Ошибка);
	
	Возврат Результат;
КонецФункции

// Удаляет из очереди ранее прочитанное сообщение
//
// Параметры:
//  ИдентификаторСервиса	 - Строка - Идентификатор сервиса для которого получаем сообщение
//  ИдентификаторСообщения	 - Стоока - Идентификатор сообщения, чтение которого завершено
// 
// Возвращаемое значение:
//	Структура:
//		* Успешно - Булево - признак успешности завершения действий
//		* Ошибка - Строка - содержит информацию об ошибке, возникшей при выполнении
//
Функция ЗавершитьЧтениеСообщенияИзОчереди(ИдентификаторСервиса, ИдентификаторСообщения) Экспорт
	Результат = Новый Структура;
	Результат.Вставить("Успешно", Ложь);
	Результат.Вставить("Ошибка", "");
	
	Рег = РегистрыСведений.КШДЯдроОчередьСообщенийУзла.СоздатьМенеджерЗаписи();
	Рег.ИдентификаторСервиса = ИдентификаторСервиса;
	Рег.ИдентификаторСообщения = ИдентификаторСообщения;
	
	Рег.Прочитать();
	Если Не Рег.Выбран() Тогда
		Результат.Ошибка = "Техническая ошибка. В очереди отсутствует указанное сообщение";
	Иначе
		Рег.Удалить();
		Результат.Успешно = Истина;
	КонецЕсли;
	
	ЗафиксироватьСобытиеОчереди(ИдентификаторСервиса, ИдентификаторСообщения, 
		Перечисления.КШДЯдроВидыСобытий.Удаление, Результат.Ошибка);
	
	Возврат Результат;
КонецФункции

// Записывает в лог очереди узла новое событие в фоне
//
// Параметры:
//  ДатаСобытия				 - Число - Время в миллисекундах фиксации события
//  ИдентификаторСервиса	 - Строка - Идентификатор сервивиса, для котого фиксируется событие
//  ИдентификаторСообщения	 - Строка - Идентификатор сообщения, для которого фиксируется событие
//  Событие					 - Перечисление.КШДЯдроВидыСобытий - Вид события
//  Ошибка					 - Строка - Информация о возничшей ошибке
//
Процедура ЗафиксироватьСобытиеОчередиВФоне(ДатаСобытия, ИдентификаторСервиса, ИдентификаторСообщения, 
	Событие, Ошибка) Экспорт
	
	Рег = РегистрыСведений.КШДЯдроЛогОчередиУзла.СоздатьМенеджерЗаписи();
	Рег.ДатаСобытия = ДатаСобытия;
	Рег.ИдентификаторСервиса = ИдентификаторСервиса;
	Рег.ИдентификаторСообщения = ИдентификаторСообщения;

	Рег.Событие = Событие;
	Рег.Ошибка = Ошибка;
	
	Рег.Записать(Истина);
КонецПроцедуры

#КонецОбласти

#Область СервисКэшированияНастроек

// Обновляет кэш основных настроек КШД
//
Процедура ОбновитьКэшОсновныхНастроек() Экспорт
	Главный = "master";
	Путь = ПолучитьПутьКФайлам(Главный);
	
	Файл = Новый Файл(Путь + "projects.json");
	Если Файл.Существует() Тогда
		Чтение = Новый ЧтениеJSON;
		Чтение.ОткрытьФайл(Путь + "projects.json");
		ДанныеПроектов = ПрочитатьJSON(Чтение, Истина);
		
		КШДЯдроВызовСервера.ЗаписатьЗначениеВКэш("", Перечисления.КШДЯдроКлючиКэшаНастроек.СписокПроектов,
			ДанныеПроектов);
	КонецЕсли;
		
	Файл = Новый Файл(Путь + "outline.json");
	Если Файл.Существует() Тогда
		Чтение = Новый ЧтениеJSON;
		Чтение.ОткрытьФайл(Путь + "outline.json");
		ДанныеКонтуров = ПрочитатьJSON(Чтение);
		
		КШДЯдроВызовСервера.ЗаписатьЗначениеВКэш("", Перечисления.КШДЯдроКлючиКэшаНастроек.МассивКонтуров,
			ДанныеКонтуров);
	КонецЕсли;
		
	Файл = Новый Файл(Путь + "nodes.json");
	Если Файл.Существует() Тогда
		Чтение = Новый ЧтениеJSON;
		Чтение.ОткрытьФайл(Путь + "nodes.json");
		ДанныеУзлов = ПрочитатьJSON(Чтение);
		Чтение.Закрыть();
		ТекущийУзел = СтрокаСоединенияИнформационнойБазы();
		Для Каждого ДанныеУзла Из ДанныеУзлов Цикл
			Если ДанныеУзла.id = ТекущийУзел Тогда
				КШДЯдроВызовСервера.ЗаписатьЗначениеВКэш("", Перечисления.КШДЯдроКлючиКэшаНастроек.УзелИдентификатор,
					ДанныеУзла.id);
				КШДЯдроВызовСервера.ЗаписатьЗначениеВКэш("", Перечисления.КШДЯдроКлючиКэшаНастроек.УзелПроект,
					ДанныеУзла.project);
				КШДЯдроВызовСервера.ЗаписатьЗначениеВКэш("", Перечисления.КШДЯдроКлючиКэшаНастроек.УзелОписание,
					ДанныеУзла.description);
				КШДЯдроВызовСервера.ЗаписатьЗначениеВКэш("", Перечисления.КШДЯдроКлючиКэшаНастроек.УзелЛокальныйПуть,
					ДанныеУзла.localpath);
				КШДЯдроВызовСервера.ЗаписатьЗначениеВКэш("", Перечисления.КШДЯдроКлючиКэшаНастроек.УзелТип,
					ДанныеУзла.type);
				КШДЯдроВызовСервера.ЗаписатьЗначениеВКэш("", Перечисления.КШДЯдроКлючиКэшаНастроек.УзелКонтуры,
					ДанныеУзла.outline);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры

// Очищает кэш основных настроек
//
// Параметры:
//  Контур - Строка - Идентификатор контура для очистки, для очистки основных - пустая строка
//
Процедура ОчиститьКэшНастроек(Контур) Экспорт
	ОбновитьПовторноИспользуемыеЗначения();
	Рег = РегистрыСведений.КШДЯдроКэшНастроек.СоздатьНаборЗаписей();
	Рег.Отбор.Контур.Установить(Контур, Истина);
	Рег.Прочитать();
	Рег.Очистить();
	Рег.Записать(Истина);
КонецПроцедуры

#КонецОбласти

#Область СервисПодключениеУзла

// Получает путь к файлам в репозитории в зависимости от опреационной системы
//
// Параметры:
//  Ветка - Строка - Имя ветки (контура) для которой необходимо получить путь
//  ПутьВнутри - Строка - Путь внутри репозитория
// 
// Возвращаемое значение:
//  Строка - Путь для указанной ветки
//
Функция ПолучитьПутьКФайлам(Ветка, ПутьВнутри = "") Экспорт
	НастройкаПодключения = Справочники.РГНастройкиРепозиториев.НайтиПоНаименованию(Ветка);
	СимволРазделения = ?(СтрНайти(НастройкаПодключения.ПутьЛокальногоХранения, "/") > 0, "/", "\");
	
	Если СимволРазделения = "/" Тогда
		ПутьВнутри = СтрЗаменить(ПутьВнутри, "\", "/");
	Иначе
		ПутьВнутри = СтрЗаменить(ПутьВнутри, "/", "\");
	КонецЕсли;
	
	Если Прав(СокрЛП(ПутьВнутри), 1) <> СимволРазделения И ЗначениеЗаполнено(ПутьВнутри) Тогда
		ПутьВнутри = ПутьВнутри + СимволРазделения;
	КонецЕсли;
	
	Возврат НастройкаПодключения.ПутьЛокальногоХранения + СимволРазделения + ПутьВнутри;
КонецФункции

#КонецОбласти

#Область СервисСервисыУзла

// Отключает сервис, если запущено регламентное задание, его отключает
//
// Параметры:
//  Идентификатор	 - Строка	 - Идентификатор сервиса
// 
// Возвращаемое значение:
//  Булево - Успешность отключения сервиса
//
Функция ОтключитьСервис(Идентификатор) Экспорт
	НачатьТранзакцию();
	Попытка
		Блокировка = Новый БлокировкаДанных;
		ОписаниеБлокировки = Блокировка.Добавить("РегистрСведений.КШДЯдроСостояниеСервисовУзла");
		ОписаниеБлокировки.УстановитьЗначение("Идентификатор", Идентификатор);
		Блокировка.Заблокировать();
		
		Рег = РегистрыСведений.КШДЯдроСостояниеСервисовУзла.СоздатьМенеджерЗаписи();
		Рег.Идентификатор = Идентификатор;
		Рег.Прочитать();
		
		Рег.Включен = Ложь;
		
		ИдентификаторРЗ = Новый УникальныйИдентификатор(Рег.ИдентификаторРЗ);
		РегЗадание = РегламентныеЗадания.НайтиПоУникальномуИдентификатору(ИдентификаторРЗ);
		СписокЗаданий = ФоновыеЗадания.ПолучитьФоновыеЗадания(Новый Структура("РегламентноеЗадание", РегЗадание));
		Для Каждого ТекЗадание Из СписокЗаданий Цикл
			ТекЗадание.Отменить();
		КонецЦикла;
		РегЗадание.Удалить();
		
		Рег.ИдентификаторРЗ = "";
		Рег.Записать(Истина);
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		ОтменитьТранзакцию();
		ОписаниеОшибки = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		// BSLLS:UsageWriteLogEvent-off
		ЗаписьЖурналаРегистрации("КШД.Ядро.Отключение сервиса", УровеньЖурналаРегистрации.Ошибка, , ,
			"При отключении сервиса " + Идентификатор + " произошла ошибка:" + Символы.ПС
			+ ОписаниеОшибки);
		// BSLLS:UsageWriteLogEvent-on
		Возврат Ложь;
	КонецПопытки;
	
	Возврат Истина;
КонецФункции

// Подключает сервис, создает регламентное задание для чтения данных
//
// Параметры:
//  Идентификатор	 - Строка	 - Идентификатор сервиса
// 
// Возвращаемое значение:
//  Булево - Успешность включения сервиса
//
Функция ПодключитьСервис(Идентификатор) Экспорт
	НачатьТранзакцию();
	Попытка
		Блокировка = Новый БлокировкаДанных;
		ОписаниеБлокировки = Блокировка.Добавить("РегистрСведений.КШДЯдроСостояниеСервисовУзла");
		ОписаниеБлокировки.УстановитьЗначение("Идентификатор", Идентификатор);
		Блокировка.Заблокировать();
		
		Рег = РегистрыСведений.КШДЯдроСостояниеСервисовУзла.СоздатьМенеджерЗаписи();
		Рег.Идентификатор = Идентификатор;
		Рег.Прочитать();
		
		Если Рег.Включен Тогда
			ВызватьИсключение "Сервис уже включен";
		КонецЕсли;
		
		Рег.Включен = Истина;
		МетаданныеРЗ = Метаданные.РегламентныеЗадания.КШДЯдроЧтениеДанныхОчереди;
		РегЗадание = РегламентныеЗадания.СоздатьРегламентноеЗадание(МетаданныеРЗ);
		РегЗадание.Ключ = Идентификатор;
		РегЗадание.Использование = Истина;
		РегЗадание.Наименование = МетаданныеРЗ.Наименование + " (" + Рег.Наименование + ")";
		МассивПараметров = Новый Массив;
		РегЗадание.Параметры.Добавить(Идентификатор);
		РегЗадание.Записать();
		
		Рег.ИдентификаторРЗ = Строка(РегЗадание.УникальныйИдентификатор);
		
		Рег.Записать(Истина);
		
		ЗафиксироватьТранзакцию();		
	Исключение
		ОтменитьТранзакцию();
		ОписаниеОшибки = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		// BSLLS:UsageWriteLogEvent-off
		ЗаписьЖурналаРегистрации("КШД.Ядро.Включение сервиса", УровеньЖурналаРегистрации.Ошибка, , ,
			"При включении сервиса " + Идентификатор + " произошла ошибка:" + Символы.ПС
			+ ОписаниеОшибки);
		// BSLLS:UsageWriteLogEvent-on
		Возврат Ложь;
	КонецПопытки;
	
	Возврат Истина;
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура ЗафиксироватьСобытиеОчереди(ИдентификаторСервиса, ИдентификаторСообщения, Событие, Ошибка = "")
	МассивПараметров = Новый Массив;
	МассивПараметров.Добавить(ТекущаяУниверсальнаяДатаВМиллисекундах());
	МассивПараметров.Добавить(ИдентификаторСервиса);
	МассивПараметров.Добавить(ИдентификаторСообщения);
	МассивПараметров.Добавить(Событие);
	МассивПараметров.Добавить(Ошибка);
	
	ФоновыеЗадания.Выполнить("КШДЯдроСервер.ЗафиксироватьСобытиеОчередиВФоне", МассивПараметров);
КонецПроцедуры

#КонецОбласти
