#Область ПрограммныйИнтерфейс

#Область СервисОчередиДанных

// Добавление нового сообщения в очередь сервиса, для которого он предназначен
//
// Параметры:
//  ИдентификаторСервиса	 - Строка	 - Идентификатор сервиса, которому должно быть доставлено сообщение
//  Контур					 - Строка	 - Контур в рамках которого отправляется сообщение
//  Пакет					 - Строка	 - Данные для передачи сообщением
//  ИдентификаторСообщения	 - Строка	 - Уникальный идентификатор сообщения (сохраняется до конца маршрута)
// 
// Возвращаемое значение:
//	Структура:
//		* Успешно - Булево - признак успешности завершения действий
//		* Ошибка - Строка - содержит информацию об ошибке, возникшей при выполнении
//
Функция ДобавитьПакетВОчередь(ИдентификаторСервиса, Контур, Пакет, ИдентификаторСообщения = Неопределено) Экспорт
	Результат = Новый Структура;
	Результат.Вставить("Успешно", Ложь);
	Результат.Вставить("Ошибка", "");
	
	Если Не ЗначениеЗаполнено(ИдентификаторСервиса) Тогда
		Результат.Ошибка = "Не указан идентификатор сервиса, для которого отправляется сообщение";
		
		Возврат Результат;
	КонецЕсли;
	//Добавить проверку наличия сервиса
	
	Если Не ЗначениеЗаполнено(Контур) Тогда
		Результат.Ошибка = "Не указан идентификатор сервиса, для которого отправляется сообщение";
		
		Возврат Результат;
	Иначе
		СписокКонтуров = КШДЯдроВызовСервера.ПолучитьСписокКонтуровКШД();
		Найден = Ложь;
		Для Каждого Контур Из СписокКонтуров Цикл
			Если Контур.id = Контур Тогда
				Найден = Истина;
			КонецЕсли;
		КонецЦикла;
		Если Не Найден Тогда
			Результат.Ошибка = "Не указан контур, для которого отправляется сообщение";
			
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(Пакет) Тогда
		Результат.Ошибка = "Пакет для передачи не содержит данных";
		
		Возврат Результат;
	КонецЕсли;
	//Добавить проверку корректности пакета
	
	Если Не ЗначениеЗаполнено(ИдентификаторСообщения) Тогда
		ИдентификаторСообщения = Строка(Новый УникальныйИдентификатор);
	КонецЕсли;
	
	МассивПараметров = Новый Массив;
	МассивПараметров.Добавить(ИдентификаторСервиса);
	МассивПараметров.Добавить(Контур);
	МассивПараметров.Добавить(Пакет);
	МассивПараметров.Добавить(ИдентификаторСообщения);
	
	ФоновыеЗадания.Выполнить("КШДЯдроСервер.ДобавитьСообщениеВОчередьВФоне", МассивПараметров);
	
	Результат.Успешно = Истина;
	
	Возврат Результат;
КонецФункции

// Фоновая процедура записи сообщения в очередь
//
// Параметры:
//  ИдентификаторСервиса	 - Строка	 - Идентификатор сервиса, которому должно быть доставлено сообщение
//  Контур					 - Строка	 - Контур в рамках которого отправляется сообщение
//  Пакет					 - Строка	 - Данные для передачи сообщением
//  ИдентификаторСообщения	 - Строка	 - Уникальный идентификатор сообщения
//
Процедура ДобавитьСообщениеВОчередьВФоне(ИдентификаторСервиса, Контур, Пакет, ИдентификаторСообщения) Экспорт
	
	Рег = РегистрыСведений.КШДЯдроОчередьСообщенийУзла.СоздатьМенеджерЗаписи();
	
	Рег.ИдентификаторСервиса = ИдентификаторСервиса;
	Рег.ДатаЗаписи = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	Рег.ИдентификаторСообщения = ИдентификаторСообщения;
	Рег.Контур = Контур;
	Рег.Пакет = Пакет;
	
	Рег.Записать(Истина);
	
КонецПроцедуры

// Получает не прочитанное ранее сообщение из очереди для конкретного сервиса
//
// Параметры:
//  ИдентификаторСервиса - Строка - Идентификатор сервиса для которого получаем сообщение
// 
// Возвращаемое значение:
//	Структура:
//		* ЕстьСообщение - Булево - признак наличия нового сообщения
//		* Ошибка - Строка - содержит информацию об ошибке, возникшей при выполнении
//		* Контур - Строка - контур сообщения
//		* Пакет - Строка - пакет сообщения
//		* ИдентификаторСообщения - Строка - идентификатор сообщения
//
Функция НачатьЧтениеСообщенияИзОчереди(ИдентификаторСервиса) Экспорт
	Результат = Новый Структура;
	Результат.Вставить("ЕстьСообщение", Ложь);
	Результат.Вставить("Ошибка", "");
	Результат.Вставить("Контур", "");
	Результат.Вставить("Пакет", "");
	Результат.Вставить("ИдентификаторСообщения", "");
	
	НастройкаУзла = КШДЯдроВызовСервера.ПолучитьДанныеУзлаКШД();
	МассивКонтуров = НастройкаУзла.outline;
	
	НачатьТранзакцию();
	Попытка

		Блокировка = Новый БлокировкаДанных;
		БлокировкаРегистра = Блокировка.Добавить("РегистрСведений.КШДЯдроОчередьСообщенийУзла");
		БлокировкаРегистра.УстановитьЗначение("ИдентификаторСервиса", ИдентификаторСервиса);
		БлокировкаРегистра.Режим = РежимБлокировкиДанных.Исключительный;
		Блокировка.Заблокировать();
		
		Запрос = Новый Запрос;
		Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
		               |	КШДЯдроОчередьСообщенийУзла.ИдентификаторСервиса КАК ИдентификаторСервиса,
		               |	КШДЯдроОчередьСообщенийУзла.ДатаЗаписи КАК ДатаЗаписи
		               |ИЗ
		               |	РегистрСведений.КШДЯдроОчередьСообщенийУзла КАК КШДЯдроОчередьСообщенийУзла
		               |ГДЕ
		               |	КШДЯдроОчередьСообщенийУзла.ВОбработке = 0
		               |	И КШДЯдроОчередьСообщенийУзла.Контур В(&Контуры)
		               |
		               |УПОРЯДОЧИТЬ ПО
		               |	ДатаЗаписи";
		РезультатЗапроса = Запрос.Выполнить();
		Если Не РезультатЗапроса.Пустой() Тогда
			Результат.ЕстьСообщение = Истина;
			
			Выборка = РезультатЗапроса.Выбрать();
			Выборка.Следующий();
			
			Рег = РегистрыСведений.КШДЯдроОчередьСообщенийУзла.СоздатьМенеджерЗаписи();
			Рег.ИдентификаторСервиса = Выборка.ИдентификаторСервиса;
			Рег.ДатаЗаписи = Выборка.ДатаЗаписи;
			
			Рег.Прочитать();
			
			Если Не Рег.Выбран() Тогда
				ВызватьИсключение "Не прочитана запись регистра очереди сообщений";
			КонецЕсли;
			
			Результат.Контур = Рег.Контур;
			Результат.Пакет = Рег.Пакет;
			Результат.ИдентификаторСообщения = Рег.ИдентификаторСообщения;
			
			Рег.ВОбработке = ТекущаяУниверсальнаяДатаВМиллисекундах();
			Рег.Записать(Истина);
		КонецЕсли;
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		Результат.Ошибка = ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		
		ОписаниеОшибки = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		
		// BSLLS:UsageWriteLogEvent-off
		ЗаписьЖурналаРегистрации("КШД.Ядро.Чтение сообщения из очереди", УровеньЖурналаРегистрации.Ошибка, , ,
			"При чтении сообщения из очереди возникла ошибка:" + Символы.ПС + ОписаниеОшибки);
		// BSLLS:UsageWriteLogEvent-on
		
	КонецПопытки;
	
	Возврат Результат;
КонецФункции

// Удаляет из очереди ранее прочитанное сообщение
//
// Параметры:
//  ИдентификаторСервиса	 - Строка - Идентификатор сервиса для которого получаем сообщение
//  ИдентификаторСообщения	 - Стоока - Идентификатор сообщения, чтение которого завершено
// 
// Возвращаемое значение:
//	Структура:
//		* Успешно - Булево - признак успешности завершения действий
//		* Ошибка - Строка - содержит информацию об ошибке, возникшей при выполнении
//
Функция ЗавершитьЧтениеСообщенияИзОчереди(ИдентификаторСервиса, ИдентификаторСообщения) Экспорт
	Результат = Новый Структура;
	Результат.Вставить("Успешно", Ложь);
	Результат.Вставить("Ошибка", "");
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	КШДЯдроОчередьСообщенийУзла.ИдентификаторСервиса КАК ИдентификаторСервиса,
	               |	КШДЯдроОчередьСообщенийУзла.ДатаЗаписи КАК ДатаЗаписи
	               |ИЗ
	               |	РегистрСведений.КШДЯдроОчередьСообщенийУзла КАК КШДЯдроОчередьСообщенийУзла
	               |ГДЕ
	               |	КШДЯдроОчередьСообщенийУзла.ИдентификаторСервиса = &ИдентификаторСервиса
	               |	И КШДЯдроОчередьСообщенийУзла.ИдентификаторСообщения = &ИдентификаторСообщения";
	РезультатЗапроса = Запрос.Выполнить();
	Если Не РезультатЗапроса.Пустой() Тогда
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		
		Рег = РегистрыСведений.КШДЯдроОчередьСообщенийУзла.СоздатьМенеджерЗаписи();
		Рег.ИдентификаторСервиса = Выборка.ИдентификаторСервиса;
		Рег.ДатаЗаписи = Выборка.ДатаЗаписи;
		
		Рег.Прочитать();
		Если Не Рег.Выбран() Тогда
			Результат.Ошибка = "Техническая ошибка. Не прочитана запись регистра очереди сообщений";
			
			Возврат Результат;
		КонецЕсли;
		
		Рег.Удалить();
	Иначе
		Результат.Ошибка = "В очереди отсутствует указанное сообщение";
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

#КонецОбласти

#Область СервисКэшированияНастроек

// Обновляет кэш основных настроек КШД
//
Процедура ОбновитьКэшОсновныхНастроек() Экспорт
	Главный = "master";
	Путь = ПолучитьПутьКФайлам(Главный);
	
	Файл = Новый Файл(Путь + "projects.json");
	Если Файл.Существует() Тогда
		Чтение = Новый ЧтениеJSON;
		Чтение.ОткрытьФайл(Путь + "projects.json");
		ДанныеПроектов = ПрочитатьJSON(Чтение, Истина);
		
		КШДЯдроВызовСервера.ЗаписатьЗначениеВКэш("", Перечисления.КШДЯдроКлючиКэшаНастроек.СписокПроектов,
			ДанныеПроектов);
	КонецЕсли;
		
	Файл = Новый Файл(Путь + "outline.json");
	Если Файл.Существует() Тогда
		Чтение = Новый ЧтениеJSON;
		Чтение.ОткрытьФайл(Путь + "outline.json");
		ДанныеКонтуров = ПрочитатьJSON(Чтение);
		
		КШДЯдроВызовСервера.ЗаписатьЗначениеВКэш("", Перечисления.КШДЯдроКлючиКэшаНастроек.МассивКонтуров,
			ДанныеКонтуров);
	КонецЕсли;
		
	Файл = Новый Файл(Путь + "nodes.json");
	Если Файл.Существует() Тогда
		Чтение = Новый ЧтениеJSON;
		Чтение.ОткрытьФайл(Путь + "nodes.json");
		ДанныеУзлов = ПрочитатьJSON(Чтение);
		Чтение.Закрыть();
		ТекущийУзел = СтрокаСоединенияИнформационнойБазы();
		Для Каждого ДанныеУзла Из ДанныеУзлов Цикл
			Если ДанныеУзла.id = ТекущийУзел Тогда
				КШДЯдроВызовСервера.ЗаписатьЗначениеВКэш("", Перечисления.КШДЯдроКлючиКэшаНастроек.УзелИдентификатор,
					ДанныеУзла.id);
				КШДЯдроВызовСервера.ЗаписатьЗначениеВКэш("", Перечисления.КШДЯдроКлючиКэшаНастроек.УзелПроект,
					ДанныеУзла.project);
				КШДЯдроВызовСервера.ЗаписатьЗначениеВКэш("", Перечисления.КШДЯдроКлючиКэшаНастроек.УзелОписание,
					ДанныеУзла.description);
				КШДЯдроВызовСервера.ЗаписатьЗначениеВКэш("", Перечисления.КШДЯдроКлючиКэшаНастроек.УзелЛокальныйПуть,
					ДанныеУзла.localpath);
				КШДЯдроВызовСервера.ЗаписатьЗначениеВКэш("", Перечисления.КШДЯдроКлючиКэшаНастроек.УзелТип,
					ДанныеУзла.type);
				КШДЯдроВызовСервера.ЗаписатьЗначениеВКэш("", Перечисления.КШДЯдроКлючиКэшаНастроек.УзелКонтуры,
					ДанныеУзла.outline);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры

// Очищает кэш основных настроек
//
// Параметры:
//  Контур - Строка - Идентификатор контура для очистки, для очистки основных - пустая строка
//
Процедура ОчиститьКэшНастроек(Контур) Экспорт
	ОбновитьПовторноИспользуемыеЗначения();
	Рег = РегистрыСведений.КШДЯдроКэшНастроек.СоздатьНаборЗаписей();
	Рег.Отбор.Контур.Установить(Контур, Истина);
	Рег.Прочитать();
	Рег.Очистить();
	Рег.Записать(Истина);
КонецПроцедуры

#КонецОбласти

#Область СервисПодключениеУзла

// Получает путь к файлам в репозитории в зависимости от опреационной системы
//
// Параметры:
//  Ветка - Строка - Имя ветки (контура) для которой необходимо получить путь
//  ПутьВнутри - Строка - Путь внутри репозитория
// 
// Возвращаемое значение:
//  Строка - Путь для указанной ветки
//
Функция ПолучитьПутьКФайлам(Ветка, ПутьВнутри = "") Экспорт
	НастройкаПодключения = Справочники.РГНастройкиРепозиториев.НайтиПоНаименованию(Ветка);
	СимволРазделения = ?(СтрНайти(НастройкаПодключения.ПутьЛокальногоХранения, "/") > 0, "/", "\");
	
	Если СимволРазделения = "/" Тогда
		ПутьВнутри = СтрЗаменить(ПутьВнутри, "\", "/");
	Иначе
		ПутьВнутри = СтрЗаменить(ПутьВнутри, "/", "\");
	КонецЕсли;
	
	Если Прав(СокрЛП(ПутьВнутри), 1) <> СимволРазделения И ЗначениеЗаполнено(ПутьВнутри) Тогда
		ПутьВнутри = ПутьВнутри + СимволРазделения;
	КонецЕсли;
	
	Возврат НастройкаПодключения.ПутьЛокальногоХранения + СимволРазделения + ПутьВнутри;
КонецФункции

#КонецОбласти

#КонецОбласти
